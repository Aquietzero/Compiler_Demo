\chapter{词法分析}

词法分析跟语法分析有很多相同的地方，工作在不同的抽象层次，所以有很多地方可以进行类比理解。其一：在词法分析中，分析的基本单元是字母表里面的符号；而在语法分析中，分析的基本单元是词法分析所向上提供的词法单元，可以知道，词法单元是由字母表中的字母所组成的，这说明语法分析工作在比词法分析更高的层次上。其二：在词法分析中，对于分析机理的描述采用的是正则表达式，而在语法分析中，对分析机理的描述是采用语法描述，这两者的本质其实都是状态机，词法分析中，状态转移接受字母表的基本符号作为输入，而在语法分析中，状态转移接受词法单元作为输入，它们的本质都是一样的，只不过工作在不同抽象层次上面；其三：在词法分析中，分析的目标是得出词法单元，而在语法分析中，分析的目标是句子，而句子正是由词法单元组成，再一次说明工作所在的抽象层次不一样。由此我们可以对比着对两者进行理解，从而找到其共性。

在词法分析中，输入是字符串，而输出是词法单元流。有两种主要的分析流程可以达到这样的目的，其中第一种为：

\begin{enumerate}
    \item 为中序正则表达式添加连接符。
    \item 将中序正则表达式转化为后序正则表达式。
    \item 根据后序正则表达式建立NFA。
    \item 将NFA转化为DFA。
    \item 将DFA的状态最小化。
\end{enumerate}

第二种方式为：

\begin{enumerate}
    \item 为中序正则表达式添加连接符。
    \item 将中序正则表达式转化为后序正则表达式。
    \item 根据后序正则表达式建立抽象语法树。
    \item 计算抽象语法树的$nullabe$，$firstpos$，$lastpos$以及$followpos$。
    \item 根据得出的数据直接构造DFA。
\end{enumerate}

由上面的步骤可以看出，两种方法都必须要先对正则表达式进行处理，鉴于时间关系，我没能把两种方法都实现，于是只实现了第一种方法。

\section{正则表达式}

正则表达式的实现是一个复杂的问题。在JavaScript里面，有现成的正则表达式工具，但基于我这次项目的目的，我打算自己实现正则表达式。在实现的过程中遇到了不少的问题。

首先，正则表达式分为基本正则表达式以及扩展正则表达式。在不同编程语言里面所提供的正则表达式工具都是强大的扩展正则表达式，其中具有很多的操作符以及诸多强大的功能。而基本的正则表达式只有三种操作：

\begin{tabular}{l|r}
    $Operations$     & $Definitions\quad and\quad Demostration$ \\
    \hline
    $Union$          & $L \cup M = \{s|s \in L \| s \in M\}$  \\
    $concatenation$  & $LM = \{st|s \in L \&\& s \in M\}$  \\
    $Kleene closure$ & $L^* = \cup^\infty_{i=0} L^i$  \\
\end{tabular}

这三种操作已经可以完全表示扩展表达式中的其他操作，所以为了实现上的简洁，我实现的是基本正则表达式。

在实现过程中遇到的另外一个重要的问题是连接符的问题，由于在输入正则表达式的时候是不会显式输入连接符，这给正则表达式的分析带来了很大的困难。比如考虑正则表达式$(a|b)*abb$，如果直接对其进行中序转后序的操作，我们得到的将会是$ab|*abb$，然而实际上这样做是不行的，因为连接操作并没有在这里体现出来，如果就这样直接进行NFA的构建，那么将会得到一个错误的自动机。解决的办法有两个，一个是在中序正则表达式加上连接符以后再转化为后序正则表达式；二是在中序正则表达式转化为后序正则表达式之后再添加连接符；考虑到括号为我们提供的诸多信息，我的实现是先为中序的正则表达式添加上连接符，如上面的正则表达式，添加上连接符以后变成：$(a|b)*\sim a\sim b\sim b$（这里假设用$\sim$来表示连接符）。这样处理以后，转化出来的后序正则表达式为：$ab|*a\sim b\sim b\sim$，这才是正确的后序转换，其后构建状态机才不会出错。

解决了这个问题以后，下一个问题随即出现：应该在什么地方添加连接符呢？之前正是为了这个原因才选择基本正则表达式的，其可能出现的情况比较少，下面可以来穷举一下几种需要添加连接符的情况：

\begin{eqnarray*}
    Char \quad Char & \rightarrow & Char \sim Char \\
    Char \quad (    & \rightarrow & Char \sim ( \\
    ) \quad Char    & \rightarrow & ) \sim Char \\
    * \quad Char    & \rightarrow & * \sim Char \\
    * \quad (       & \rightarrow & * \sim ( \\
    ) \quad (       & \rightarrow & ) \sim ( \\
    any \quad endmarker & \rightarrow & any \sim endmarker \\
\end{eqnarray*}

上面的情况应该也很容易理解，就拿第一种情况来说，如果两个字母表中的字符粘连在一起，那么它们之间必定有一个连接符，因为没有0元操作符可以连接两个字符。又比如右括号和字符之间必定有连接符，右括号预示着一个部分的结束，它后面除非是结束，不然一定需要一个左结合的运算符将其与后面的部分连接，所以这种情况也必须要添加连接符。其余的如此类推。   

解决了这些问题以后，就可以思考正则表达式的数据结构了。首先正则表达式是一个字符串，故可以用字符串来表示正则表达式，考虑到正则表达式需要时时查询字母表，所以有必要把字母表也记录下来，故正则表达式的数据结构可以简单地表示为：

\begin{verbatim}

ReExpression:
    reExp    -> Array(Char) # 正则表达式
    alphabet -> Array(Char) # 正则表达式所表示语言的字母表

\end{verbatim}

有了正则表达式的基本模型以后，可以根据上面的讨论很轻易地写出添加连接符的$insertConcatenation$函数，其伪代码如下：

\begin{verbatim}

function insertConcatenation:
  left  = reExp[0]
  right = reExp[1]

  while (right != endmarker):
    if left and right satisfy the conditions above:
      reExp.insert('~')

    left moves forward
    right moves forward

\end{verbatim}

这里在实现的时候有一个问题需要注意，那就是插入连接符的动作其实是对原字符串进行了修改，如果整个过程都在原字符串上面操作，那么在每次插入之后都必须显式将下标向前移动，以配合新插入的连接符。如果上面的步骤是在一个全新的字符串上面进行操作，那么就不会出现下标错位的问题。
