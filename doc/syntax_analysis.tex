\chapter{语法分析}

语法分析是编译流水线的第二个部分，语法分析器接受词法分析器所提供的词法单元流，根据给定的语法判断词法单元流是否符合语法。语法分析有两种主要的方法，一种是自顶向下语法分析，另一种是自底向上语法分析。在自顶向下语法分析中，语法分析器从语法的开始符号出发，构造一棵词法单元流的语法分析树；而在自底向上的语法分析中，语法分析器根据移入归约原则，将词法单元流转化为语法的初始符号，其过程中的每一步都对应着该词法单元流最右推导的中间过程。

在语法分析部分，对于自顶向下的语法分析，我实现了$LL(1)$预测分析；对于自底向上的语法分析，我实现了$SLR$以及$LR(1)$。在这些方法的实现过程中，需要到很多的辅助函数，而这些辅助函数都起到了至关重要的作用，下面结合我对语法分析的理解，逐一介绍它们的实现过程。

\section{语法模型}

在语法分析的实现过程中，首当其冲的问题就是为语法选择一个合适的数据结构，一个高效的数据结构非常重要，但高效的数据结构同时又可能难以令人理解。为了均衡高效以及良好阅读性的矛盾，数据结构必须仔细地进行设计。由于JavaScript并没有提供什么数据结构，所以必须自己根据需要来实现。同时，由于数据结构是根据自身来进行实现的，所以比较灵活。下面围绕着书中的表达式文法作为例子，来阐述我的设计过程。一个具有非左递归的文法如下：

\begin{eqnarray*}
    E  & \rightarrow & TE'               \\
    E' & \rightarrow & +TE' | \epsilon   \\
    T  & \rightarrow & FT'               \\
    T' & \rightarrow & *FT' | \epsilon   \\
    F  & \rightarrow & (E) | id          \\
\end{eqnarray*}

从上面的语法可以看出，语法最直观的一个模型就是数组，或者是链表，其基本元素是产生式。其实在JavaScript里面，只提供了对象以及数组两个比较高级的数据结构，其实数组也是对象，所以在我的整个系统里面，数据结构基本上都是根据简单的数组组合构建而成的。既然语法是一个产生式的数组，那么产生式又应该如何表示呢？观察下面的产生式：

\begin{eqnarray*}
    \underbrace{E'}_\text{产生式头} \rightarrow 
    \underbrace{+TE'}_\text{产生式体1} |
    \underbrace{\epsilon}_\text{产生式体2}
\end{eqnarray*}

可以观察到产生式由两个部分组成，一个是产生式头，另一个是产生式体，而由于一个产生式可以有多个产生式体，所以可以用数组来存放一个产生式的所有产生式体。在这里有一个问题是需要注意的，那就是\begin{bfseries}在这里假定每个非终结符号对应一个产生式的数据结构。\end{bfseries}简单地说，就是不会出现下面的结构：

\begin{eqnarray*}
    E' & \rightarrow & +TE' \\
    E' & \rightarrow & \epsilon \\
\end{eqnarray*}

当然，这也是一种合法的语法表示形式，是没有理由禁止的，但为了处理的方便，当用户以这样的方式进行输入的时候，一个称为$reduceRedundancy$的函数会消除这种冗余，即将这样的情况转化为上面的那种用``$|$''来表示的形式。

当然，上面的描述足以表示产生式以及语法两个抽象概念，但是考虑到运算时有一些额外的量是需要的，将这些量绑定到这两个数据结构有助于提高运算效率。例如，在求$First$和$Follow$集的时候，需要查看语法中的终结符号，所以有必要把终结符集合也绑定到语法的数据结构中；又如，在计算预测分析表的时候，需要随时用到某一个非终结符的$First$和$Follow$集的结果，所以把这两个集合也绑定到产生式中也是非常重要的。基于这些考虑，可以得到下面的语法数据结构和产生式数据结构的伪代码。

\begin{verbatim}
    Grammar:
        terminals   -> Array(String)     # 终结符集合
        productions -> Array(Production) # 产生式集合

    Production:
        head   -> Char            # 产生式头
        bodies -> Array(String)   # 产生式体集合
        first  -> Array(String)   # First集
        follow -> Array(String)   # Follow集
\end{verbatim}

\newpage

